// Copyright (C) 2020 Storj Labs, Inc.
// See LICENSE for copying information.

package sharing

import (
	"context"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/zeebo/errs"
	"go.uber.org/zap"

	"storj.io/common/memory"
	"storj.io/common/ranger/httpranger"
	"storj.io/linksharing/objectranger"
	"storj.io/uplink"
	"storj.io/uplink/private/object"
)

// Location represents geographical points
// in the globe.
type Location struct {
	Latitude  float64
	Longitude float64
}

// handleTraditional deals with normal linksharing that is accessed with the URL generated by the uplink share command.
func (handler *Handler) handleTraditional(ctx context.Context, w http.ResponseWriter, r *http.Request, locationOnly bool) error {
	rawRequest, access, serializedAccess, bucket, key, err := parseRequestPath(r.URL.Path, handler.authConfig)
	if err != nil {
		return err
	}

	p, err := uplink.OpenProject(ctx, access)
	if err != nil {
		return WithAction(err, "open project")
	}
	defer func() {
		if err := p.Close(); err != nil {
			handler.log.With(zap.Error(err)).Warn("unable to close project")
		}
	}()

	if key == "" || strings.HasSuffix(key, "/") {
		if !strings.HasSuffix(r.URL.Path, "/") {
			// Call redirect because directories must have a trailing '/' for the listed hyperlinks to generate correctly.
			http.Redirect(w, r, r.URL.Path+"/", http.StatusMovedPermanently)
			return nil
		}
		err = handler.servePrefix(ctx, w, p, breadcrumb{
			Prefix: bucket,
			URL:    "/" + serializedAccess + "/" + bucket + "/",
		}, bucket, bucket, key, key)
		if err != nil {
			return err
		}
		return nil
	}

	o, err := p.StatObject(ctx, bucket, key)
	if err != nil {
		return WithAction(err, "stat object")
	}

	if locationOnly {
		location := makeLocation(handler.urlBase, r.URL.Path)
		http.Redirect(w, r, location, http.StatusFound)
		return nil
	}

	_, download := r.URL.Query()["download"]
	_, view := r.URL.Query()["view"]
	if !download && !view && !rawRequest {
		ipBytes, err := object.GetObjectIPs(ctx, uplink.Config{}, access, bucket, key)
		if err != nil {
			return WithAction(err, "get object IPs")
		}

		var locations []Location
		if handler.mapper != nil {
			for _, ip := range ipBytes {
				info, err := handler.mapper.GetIPInfos(string(ip))
				if err != nil {
					handler.log.Error("failed to get IP info", zap.Error(err))
					continue
				}

				location := Location{
					Latitude:  info.Location.Latitude,
					Longitude: info.Location.Longitude,
				}

				locations = append(locations, location)
			}
		}

		var input struct {
			Key       string
			Size      string
			Locations []Location
			Pieces    int64
		}
		input.Key = o.Key
		input.Size = memory.Size(o.System.ContentLength).Base10String()
		input.Locations = locations
		input.Pieces = int64(len(locations))

		return handler.templates.ExecuteTemplate(w, "single-object.html", input)
	}

	if download {
		segments := strings.Split(key, "/")
		obj := segments[len(segments)-1]
		w.Header().Set("Content-Disposition", "attachment; filename=\""+obj+"\"")
	}
	httpranger.ServeContent(ctx, w, r, key, o.System.Created, objectranger.New(p, o, bucket))
	return nil
}

func parseRequestPath(p string, cfg AuthServiceConfig) (rawRequest bool, _ *uplink.Access, serializedAccess, bucket, key string, err error) {
	// Drop the leading slash, if necessary.
	p = strings.TrimPrefix(p, "/")

	// Split the request path.
	segments := strings.SplitN(p, "/", 4)
	if len(segments) == 4 {
		if segments[0] == "raw" {
			rawRequest = true
			segments = segments[1:]
		} else {
			// If its not a raw request, we need to concat the last two entries as those contain paths in the bucket
			// and shrink the array again.
			rawRequest = false
			segments[2] = segments[2] + "/" + segments[3]
			segments = segments[:len(segments)-1]
		}
	}
	if len(segments) == 1 {
		if segments[0] == "" {
			return rawRequest, nil, "", "", "", WithStatus(errs.New("missing access"), http.StatusBadRequest)
		}
		return rawRequest, nil, "", "", "", WithStatus(errs.New("missing bucket"), http.StatusBadRequest)
	}

	serializedAccess = segments[0]

	bucket = segments[1]

	if len(segments) == 3 {
		key = segments[2]
	}

	access, err := parseAccess(serializedAccess, cfg)
	if err != nil {
		return rawRequest, nil, "", "", "", err
	}

	return rawRequest, access, serializedAccess, bucket, key, nil
}

func makeLocation(base *url.URL, reqPath string) string {
	location := *base
	location.Path = path.Join(location.Path, reqPath)
	return location.String()
}
